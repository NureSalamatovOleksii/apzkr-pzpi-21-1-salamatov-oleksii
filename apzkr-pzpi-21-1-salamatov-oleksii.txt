Міністерство освіти і науки України 
Харківський національний університет радіоелектроніки 
  
Факультет комп’ютерних наук 
  
Кафедра програмної інженерії 
  
КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення» 
Тема роботи: Програмна система для контролю здачі та переробки сміття
  	 	 
Студент гр. ПЗПІ-21-1    	________________ Саламатов О.В. 
(підпис)  
Керівник роботи    	  
 
 	________________ доц. Лещинський В.О.  
(підпис)  
Роботу захищено «__»_________2024 р. з оцінкою _________________________  
Комісія: 	 	 	 	_________________ доц. Лещинський В.О.  
(підпис)  
                                                         _________________ доц. Лещинська І.О.    
(підпис)  
_________________ ст.викл. Сокорчук І.П. 
(підпис)  


Харків
2024 р. 
Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук Кафедра програмної інженерії______________ Спеціальність 121 – Інженерія програмного забезпечення_________________  
Курс ______3_______Семестр _________________6______________________  
Навчальна дисципліна  Архітектура програмного забезпечення____________ 
ЗАВДАННЯ 
НА КУРОСВУ РОБОТУ СТУДЕНТОВІ  
                                  Саламатову Олексію В’ячеславовичу______________           
1.	Тема проєкту: «Програмна система для контролю здачі та переробки_сміття «Smart Recycling»______________________________
2.	Термін узгодження завдання курсової роботи «29» березня 2024 р. 
3.	Термін здачі студентом закінченої роботи «10» червня 2024 р.  
4.	Вихідні дані до проєкту (роботи): В програмній системі передбачити: перегляд точок збору сміття, взаємодію з ними, адміністрування системи, додавання нових даних, збір статистики. Використовувати ОС Windows 10, СКБД Microsoft SQL Server 2019, середовище розробки Microsoft Visual Studio 2022, Visual Studio Code________________________________________________________
5.	Зміст пояснювальної записки (перелік питань, що належить розробити) вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки_____________________________________________
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень): ER-діаграма бази даних, логічна схема бази даних, діаграма прецедентів серверної частини програмної системи, діаграма розгортання серверної частини програмної системи, діаграма пакетів серверної частини програмної системи, діаграма прецедентів IoT частини програмної системи, будова пристрою IoT частини програмної системи, діаграма пакетів IoT частини програмної системи, діаграма взаємодії IoT частини програмної системи, діаграма діяльності IoT частини програмної системи, діаграма прецедентів клієнтської частини програмної системи, діаграма пакетів клієнтської частини програмної системи, діаграма компонентів клієнтської частини програмної системи, діаграма взаємодії клієнтської частини програмної системи, головна сторінка сайту, сторінка пунктів прийому сміття, сторінка авторизації, сторінка реєстрації, сторінка входу в систему, сторінка профілю з облікового запису адміністратора, сторінка профілю з облікового запису клієнта, сторінки адміністрування системи з таблицями пунктів прийому  та користувачів, сторінка перегляду пункту прийому, сторінка редагування пункту прийому, вікно редагування операції, результат перевірки на плагіат
 
КАЛЕНДАРНИЙ ПЛАН


№   	 	Назва етапів курсової роботи    	Термін виконання етапів роботи	Примітка   
1  	Функціональна специфікація програмного проекту  	13.04.2024 	виконано    
2  	Проектування програмного проекту  	30.04.2024 	виконано    
3  	Кодування програмного проекту  	20.05.2024  	виконано    
4  	Оформлення пояснювальної записки  	01.06.2024 	виконано    
5  	Захист курсової роботи  	08.06.2024  	виконано    

Дата видачі завдання «29» березня 2024 р.
  
Керівник                              ____________ доц. Лещинський В.О.				                                      (підпис)  

Завдання прийняв до виконання 
ст.гр. ПЗПІ-21-1                      ____________             Саламатов О. В.
     (підпис)
 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 85 с., 26 рис., 2 табл., 4 додатки, 5 джерел. 
     АДМІНІСТРАТОР, ЗБІР СМІТТЯ, КЛІЄНТ, МОНІТОРИНГ, ПЕРЕРОБКА, ПРОГРАМНА СИСТЕМА, ПУНКТИ ПРИЙОМУ, СОРТУВАННЯ СМІТТЯ, ТОЧКИ ПЕРЕРОБКИ, ТРАНСПОРТУВАННЯ.
     Об’єктом дослідження є переробка сміття, а саме: актуальне на сьогоднішній день питання щодо вирішення проблеми зручного та ефективного збору, сортування та переробки відходів. 
     Метою курсової роботи є створення продукту, який дозволяє ефективно управляти процесами збору та переробки відходів. Система забезпечує автоматизований моніторинг місць збору сміття, оптимізацію маршрутів для транспортування відходів, контроль їх вивозу, дозволяє відстежувати стан сміттєвих контейнерів у реальному часі. Підтримується оновлення даних про переробку відходів, інтеграцію з підприємствами, що займаються утилізацією, та отримання статистики відносно роботи системи.
Методи розробки базуються на технології ASP.NET Core з використанням мови програмування C#, серверу бази даних MS SQL Server [1], вебзастосунок базується на технології React з мовою програмування JavaScript, смарт пристрій розроблено на платі ESP32 WiFi, ультразвукового датчика відстані HC-SR04, підсилювача тензодатчика HX711, монохромного OLED-дисплею, п’єзоелектричного гудка, трьох світлодіодів, одного RGB діоду та двох кнопок за допомогою онлайн-платформи Wokwi.com та реалізації мови програмування Python MicroPython.
     У результаті роботи здійснено програмну реалізацію системи для контролю здачі та переробки сміття. Програмна система складається з вебзастосунку, сервера та розумного пристрою.
ЗМІСТ


Вступ	6
1 Аналіз предметної області	7
1.1 Бізнес-вимоги	7
1.1.1 Бізнес-можливості	7
1.1.2 Бізнес-цілі та критерії успіху	7
1.1.3 Потреби клієнтів або ринку	8
1.1.4 Бізнес-ризики	9
1.2 Концепція рішення	9
1.2.1 Окреслення концепції	9
1.2.2 Головна функціональність	10
1.2.3 Припущення та залежності	11
1.3 Рамки та обмеження проєкту	11
1.3.1 Рамки первинного випуску	11
1.3.2 Рамки наступних випусків	13
1.3.3 Обмеження та винятки	14
1.4 Бізнес-контекст	15
1.4.1 Профілі зацікавлених сторін	15
1.4.2 Пріоритети проєкту	16
1.4.3 Робоче середовище	17
2 Постановка задачі	19
3 Проєктування бази даних	21
3.1 Побудова er-діаграми	21
3.2 Побудова логічної моделі бази даних на основі er-діаграми	22
4 Архітектура програмної системи	26
4.1 Архітектура серверної частини	26
4.2 Архітектура IoT частини	30
4.3 Архітектура клієнтської частини	38
5 Опис програмної системи	43
5.1 Виклик і завантаження	43
5.2 Призначення і логічна структура	44
5.3 Опис програмної реалізації	45
Висновки	53
Перелік джерел посилання	54
Додаток А	55
Додаток Б	56
Додаток В	67
Додаток Г	73

 
ВСТУП


У сучасному світі проблема утилізації та переробки сміття стає все більш актуальною. Зростання населення та промислове виробництво призводять до значного збільшення обсягів твердих побутових відходів, що потребують ефективного управління. Неефективна система контролю за збором, здачею та переробкою сміття може спричинити значні екологічні, економічні та соціальні проблеми.
З метою вирішення цих проблем була розроблена Програмна система для контролю здачі та переробки сміття. Вона спрямована на автоматизацію процесів збору, сортування та переробки відходів, а також на покращення взаємодії між комунальними службами, підприємствами з переробки сміття та населенням.
Система дозволить підняти на новий рівень процес обробки сміття, зробити його більш доступним, ефективним і керованим, а дані більш упорядкованими та захищеними. Використовуючи цю систему, користувач відчуватиме свою важливу роль у збереженні довкілля та буде отримувати стимули для активної участі у цьому. Потрібно піклуватися про майбутнє нашої планети вже зараз. 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості


Ринкові можливості для цього проекту значні. Здача та переробка сміття зараз у тренді, все більше людей хочуть дотримуватися свідомого споживання та «zero waste» підходу. Здача та правильна переробка сміття є надзвичайно важливою активністю для країни з постійним потоком матеріалу для обробки. Завдяки автоматизації та оцифруванню процесів ця система може значно підвищити ефективність боротьби із зростаючою кількістю відходів та площі відведеної під них, а також покращить функціонування всієї логістики, що пов’язана з подібною діяльністю. Існуючі рішення часто застаріли та не використовують потенціал Інтернету речей і аналізу даних. Ця система має намір заповнити цю прогалину, пропонуючи комплексну, технологічно просунуту платформу для управління здачею та переробкою сміття.
З точки зору ринку, користувачі та адміністратори зіткнулися з власними труднощами. Кажучи про перших, для користувачів часто складно знайти пункт прийому сміття чи отриманні винагороди за нього. З точки зору адміністратора, за допомогою цієї системи вони можуть легко відстежувати в режимі реального часу всі дані щодо зданого  та переробленого сміття, його кількості, тип, хто його та в якому пункті здав тощо. Весь процес буде триматися під контролем, і в разі необхідності буде можливість втрутитися та відредагувати, наприклад, якісь ланцюги постачання.


1.1.2 Бізнес-цілі та критерії успіху


BO-1: Підвищити швидкість та ефективність збору, а також управління зданим сміттям.
BO-2: Знизити операційні витрати.
BO-3: Запровадити пристрої IoT для збору та аналітики даних у реальному часі.
BO-4: Збільшити об’єми перероблених відходів.
BO-5: Зменшити кількість сміття, що потрапляє у довкілля.
SC-1: Щомісячні показники зростаючого залучення сміття.
SC-2: Зменшення помилок при ручному опрацюванні даних.
SC-3: Підвищення відсотка переробки.
SC-4: Підвищення рівня задоволеності користувачів.
SC-5: Зменшення викидів шкідливих речовин, що потрапляють у довкілля.


1.1.3 Потреби клієнтів або ринку


Система управління зданим сміттям буде обслуговувати різні зацікавлені сторони, включаючи користувачів, пункти прийому та сміттєпереробних заводів. Потреби клієнтів і ринку включають:
	Зручність і доступність сортування сміття для всіх.
	Відстеження та аналіз даних про сміття в обробці у реальному часі.
	Автоматизоване сортування.
	Фінансові стимули для користувачів.
	Прогностична аналітика для визначення результативності роботи системи.
	Повна інтеграція з пристроями IoT для збору та аналізу важливої інформації про зібране сміття.
	Сумісність з різними апаратними та програмними середовищами.
	Скорочення часу на позбавлення від сміття і загального часу на його переробку.


1.1.4 Бізнес-ризики


Основні бізнес-ризики, пов’язані з цим проектом, включають:
	Конкуренція з боку існуючих усталених систем і потенційний опір змінам з боку класичних організацій та комунальних служб.
	Питання термінів, пов’язані з розробкою та розгортанням системи.
	Прийняття користувачами, оскільки клієнти можуть мати занепокоєння щодо конфіденційності та безпеки даних.
	Проблеми технічної реалізації з пристроями IoT та аналізом даних.
	Негативний вплив на бізнес, якщо система не відповідає нормативним вимогам або стандартам безпеки.
	Ігнорування користувачами через небажання вникати у тему.
Щоб пом’якшити ці ризики, ми запровадимо комплексну стратегію управління змінами, включаючи навчання для всіх зацікавлених сторін, налаштуємо зворотній зв’язок, проведемо ретельне тестування та гарантію якості, а також запровадимо надійні заходи захисту даних відповідно до відповідних нормативних актів.


1.2 Концепція рішення
1.2.1 Окреслення концепції


Система дозволить підняти на новий рівень процес обробки сміття, зробити його більш доступним, ефективним і керованим, а дані більш упорядкованими та захищеними. Використовуючи цю систему, користувач відчуватиме свою важливу роль у збереженні довкілля та буде отримувати стимули для активної участі у цьому. Потрібно піклуватися про майбутнє нашої планети вже зараз.


1.2.2 Головна функціональність


Основні характеристики, які відрізнятимуть це рішення, включають:
MF-1: керування мережею центрів збору та переробки, тобто централізована платформа для реєстрації сміття та менеджменту його правильної ліквідації.
MF-2: інтеграція з пристроями Інтернету речей для збору даних про надходження матеріалу у режимі реального часу.
MF-3: аналіз даних, підбір правильного сортування та стратегії переробки сировини.
MF-4: автоматичні сповіщення про успішний внесок та бонуси при здачі сміття для підвищення мотивації.
MF-5: інструменти для посилення залучення людей до екологічної ініціативи, включаючи систему винагород і форум спільноти.
MF-6: комплексні інструменти для зацікавлених компаній для аналізу та моніторингу матеріалу, що надходить.
MF-7: підбір найбільш підходящих пунктів прийому сміття.
MF-8: зворотній зв’язок для пропонування власних еко-ініціатив.


1.2.3 Припущення та залежності


A-1: проект передбачає наявність необхідної апаратно-програмної інфраструктури для підтримки пристроїв IoT;
A-2: готовність людей прийняти цифрову платформу для ведення обліку та реєстрації;
A-3: користувачі будуть мати доступ до Інтернету для використання системи «Smart Recycling»;
A-4: мобільній додаток відображає актуальну інформацію про пункти прийому та дозволяє зареєструвати здану сировину;
D-1: проект залежить від успішної інтеграції зі сторонніми постачальниками апаратного забезпечення IoT для збору даних про отриману сировину;
D-2: успішне партнерство з підприємствами переробки та еко-організаціями, та регуляторними органами має вирішальне значення для обміну даними та відповідності;
D-3: чим більше активних користувачів зареєстровано, тим успішніше та дохідніше система;
D-4: Реалізація деяких функцій може залежати від зовнішніх сервісів або API.


1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Програмна система складається із чотирьох компонентів: back-end, front-end, mobile app, IoT. Кожна частина взаємодіє з іншими для розширення функціоналу та утворення повноцінної екосистеми.
1)	Back-end
 Серверна частина системи «Smart Recycling» приймає певні запити від користувачів через веб-інтерфейс або мобільний застосунок і після чого серверна частина робить запити до бази даних для отримання інформації, необхідної для обробки запиту. І в кінці серверна частина повертає відповіді користувачам у форматі JSON. 
2)	Front-end
 Клієнтська частина системи «Smart Recycling» розробляється з урахуванням потреб користувачів, адміністраторів. Всі ці категорії мають різний рівень доступу та функціональності на платформі. 
Для всіх користувачів: 
− створити обліковий записи та увійти в систему;
− налаштовувати профіль та особисті дані; 
− є доступ до пунктів здачі сміття;
− можливість пройти тест на придатність сировини для здачі;
− автоматичний підбір підходящих пунктів прийому;
− можливість отримувати бонуси та винагороди за успішно здане сміття.
Додатково для адміністраторів: 
−	додавання та редагування різного роду даних;
−	видалення акаунта користувачів за порушення правил;
−	контроль та моніторинг процесів всього ланцюга переробки;
−	додавання новин на головній сторінці сайту;
3)	Mobile застосунок 
В рамках первинного випуску усі користувачі мають один і той же функціонал. 
Для всіх користувачів: 
− створити обліковий записи та увійти в систему. 
− налаштовувати профіль та особисті дані. 
− є доступ до головного функціоналу.
− застосування геолокації.
− генерація QR-коду для реєстрації передачі сміття до пункту прийому.
− можливість отримувати бонуси за регулярність здачі сировини.
− оповіщення про відкриття нового пункту прийому.
4) IoT застосунок
 Для всіх користувачів: 
−	визначення придатності сміття для здачі;
−	аналіз та реєстрація зданої сировини;
−	надання додаткової підтримки.


1.3.2 Рамки наступних випусків


Подальші випуски системи розумного керування зібраним сміттям базуватимуться на початковому випуску та запровадять розширені функції. Ці функції можуть включати:
	Розширення підтримки видів відходів, що потребують спеціалізованих модулів обробки.
	Прогностична аналітика та звітність: реалізувати алгоритми прогнозування, щоб визначити персональний внесок у користувача у зменшенні відходів.
	Розширене залучення потенційних клієнтів: функції гейміфікації та соціальної інтеграції для подальшого залучення людей і створення відчуття спільності у боротьбі зі спільною проблемою.
	Мобільні додатки: розробка мобільних додатків для користувачів та організаторів для доступу до платформи на своїх смартфонах.
	Інтеграція з сміттєпереробними центрами: інтеграція з електронними системами цих організацій та доступ до їх потужностей для більш ефективної роботи всього ланцюга переробки.
	Розширена сумісність з Інтернетом речей: сумісність із широким спектром пристроїв Інтернету речей для аналізу прийнятої сировини.


1.3.3 Обмеження та винятки


Хоча система для контролю та переробки сміття програмного забезпечення має на меті бути комплексним рішенням для екосистеми обробки відходів, що надходять, існують певні обмеження та винятки, про які слід знати, зокрема:
	Обмеження на прийом токсичних відходів.
	Зареєструвати себе як партнера програми, можна з 16 років.
	Відповідність нормативним вимогам: система відповідатиме відповідним нормам захисту даних, дотримання міжнародних стандартів.
	Система не зможе замінити найближчим часом смітники для загального збору сміття.
	Проблема доступності у віддалених районах.
	Складнощі  з прийомом надзвичайно сміття великих об’ємів спеціалізованими смітниками.
	Залежності від обладнання: успіх інтеграції IoT залежить від наявності та сумісності відповідного обладнання.
Ці обмеження та виключення необхідні для забезпечення цілеспрямованого, практичного та ефективного рішення, забезпечуючи при цьому чітке розуміння меж системи.


1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


Профілі зацікавлених сторін проекту наведені в таблиці 1.1.

Таблиця 1.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Місцеві жителі	Очищення довкілля, зниження рівня забруднення	Підтримка	Оптимізація процесу збору та переробки сміття, зменшення кількості відходів на території	Підвищення тарифів на вивезення сміття
Промислові підприємства	Зменшення витрат на утилізацію відходів, підвищення ефективності виробництва	Обережне ставлення	Знаходження ефективних та економічно доцільних методів переробки та використання відходів	Технічні обмеження, нестабільність ринку вторинної сировини
Екологічні організації	Зменшення впливу на довкілля, просування зелених технологій	Активна підтримка	Збільшення обсягів вторинної переробки, сприяння використанню відновлюваних ресурсів	Обмеженість фінансування, потреба у додаткових дослідженнях
Місцеві органи влади	Забезпечення екологічної стабільності та відповідність нормативним актам	Підтримка	Зменшення впливу сміття на довкілля, поліпшення якості життя мешканців	Фінансові обмеження, політичний тиск


1.4.2 Пріоритети проєкту


Пріоритети проєкту наведені в таблиці 1.2.

Таблиця 1.2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План	випуск 1.0 стане доступним до 10.05.2024 
випуск 1.1 – до 10.06.2024		
Функції			70% - 80%  функцій із 
високим пріоритетом 
мають бути  включені до 
випуску 1.0
Якість			Система не має критичних помилок, які повністю руйнують її працездатність.
Команда		Максимальний розмір команд: 1	
Бюджет			Вкластись у встановлений грошовий ліміт


1.4.3 Робоче середовище


Система включає в себе чотири ключові компоненти: back-end, front-end, мобільний додаток та IoT. Планується будувати серверну частину з використанням ASP.NET Core Web API та MS SQL Server, тому необхідно забезпечити серверну частину всім необхідним обладнанням для роботи з цими технологіями. Усі запити до сервера повинні бути захищені та передаватись за допомогою протоколу HTTPS. 
Front-end буде розроблено з використанням HTML, CSS, JavaScript, на цій основі інтерфейс буде розроблено за допомогою фреймворків JavaScript як, наприклад React.js. Для забезпечення максимально комфортного користувацького досвіду необхідно користуватися браузером, який підтримує HTML 5. 
Оскільки мобільні операційні системи швидко розвиваються і деякі функції можуть втратити підтримку, для впровадження всіх запланованих функцій мобільного додатка використовувати операційну систему Android 9 вважається мінімально допустимою. Розроблення додатку буде проходити за допомогою технології Xamarin.
Наша задача врахувати всі нюанси, щоб зробити програму якнайбільш доступно, стабільною на ефективною, тож, варто виділити певні пункти, що стосуються надійності системи:
	Дані генеруються та використовуються в багатьох місцях, включаючи центри переробки, сайти компаній тощо. Може виникнути потреба в консолідації даних для централізованого аналізу та звітності.
	Конкретний максимальний час відповіді для доступу до віддалених даних буде визначено на етапі проектування системи, щоб відповідати очікуванням користувачів.
	Безперервний доступ до системи є дуже важливим. Однак система повинна бути розроблена таким чином, щоб мінімізувати перебої в обслуговуванні, наскільки це можливо.
	Для забезпечення конфіденційності та безпеки даних, особливо для конфіденційної інформації про користувачів, необхідні надійні засоби контролю безпеки доступу та суворі заходи захисту даних, що будуть впроваджені за допомогою безпечних протоколів передачі інформації та аутентифікації для доступу до даних.
	Резервне копіювання та відновлення даних дозволить уникнути втрати даних та забезпечити аварійного відновлення в разі необхідності.

 
2 ПОСТАНОВКА ЗАДАЧІ


За результатами попереднього аналізу предметної області, задачею курсової роботи було поставлено створення програмної системи для контролю здачі та переробки сміття.
База даних повинна включати інформацію про: користувачів, зокрема статистика для клієнтів, операції, пункти прийому та статистика до них, транспортування, точки переробки.
Для клієнта має бути реалізовано наступний функціонал:
	реєстрація та вхід в систему;
	перегляд доступних пунктів прийому сміття;
	перегляд особистих статистичних даних;
	перегляд, редагування власних даних;
	видалення акаунту;
	нарахування бонусів за здане сміття;
Для адміністратора системи має бути реалізований такий функціонал:
	реєстрація та вхід в систему;
	перегляд, редагування власних даних;
	керування користувачами системи;
	перегляд, додавання, редагування, видалення даних;
	перегляд стану пунктів прийому сміття та точок переробки;
	експорт та імпорт даних системи;
	формування звітів із статистикою роботи пунктів прийому;
Крім того, програмна система повинна підтримувати локалізацію та інтернаціоналізацію, а саме, забезпечувати: підтримку різних кодових таблиць символів, обчислення та формат дати та часу, локальний та універсальний час, метричні одиниці вимірювання, англійську та американську систему мір, порядок сортування текстових значень, різні напрями введення тексту тощо. 
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
3.1 Побудова ER-діаграми


В цьому підрозділі описано та розроблено таблиці в базі даних та зв’язки між ними. На рисунку нижче (див. рис. 3.1) показано, які сутності було отримано на підставі концептуальної моделі предметної області, що була описана в першому розділі.
 
Рисунок 3.1 – ER-діаграма бази даних

Сутність Користувачі – це сутність, яка містить інформацію про користувачів системи, і пов’язана зв’язком «один-до-багатьох» із сутністю Операції та «один-до-одного» з сутністю Статистика користувачів.
     Сутність Статистика користувачів – це сутність, що містить інформацію про статистику користувачів та накопичені бонуси, і пов’язана зв’язком «один-до-одного» із сутністю Користувачі.
     Сутність Операції – це сутність, що містить інформацію про здійснені користувачами операції зі здачі сміття у пункті прийому, і пов’язана зв’язком «один-до-багатьох» із сутностями Користувачі та Пункти прийому.
     Сутність Пункти прийому – це сутність, що містить інформацію про пункти пункти прийому сміття та їх стан, і пов’язана із сутностями Статистика пунктів прийому, Зміст пунктів прийому, Транспортування та Операції зв’язком «один-до-багатьох».
     Сутність Статистика пунктів прийому – це сутність, що містить інформацію про статистику пунктів прийому сміття, і пов’язана із сутністю Пункти прийому зв’язком «один-до-багатьох».
     Сутність Зміст пунктів прийому – це сутність, що містить інформацію про складові пункту прийому сміття, їх стан та типи відходів, що приймаються, і пов’язана із сутністю Пункти прийому зв’язком «один-до-багатьох».
     Сутність Транспортування – це сутність, що містить інформацію про транспортування зібраного сміття від пунктів прийому до точок переробки, і пов’язана із сутностями Пункти прийому та Точки переробки зв’язком «один-до-багатьох».
     Сутність Точки переробки – це сутність, що містить інформацію про точки переробки сміття певного типу, із сутністю Транспортування зв’язком «один-до-багатьох».


3.2 Побудова логічної моделі бази даних на основі ER-діаграми


На основі розробленої ER-діаграми було розроблено схему реляційної бази даних, яка містить повний набір таблиць, які пов’язані з предметною областю контролю збору та переробки сміття. Схема виконана англійською мовою, крім того до неї було додано зовнішні ключі. 
Основною діяльністю профілакторію є розміщення клієнтів у номерах з можливістю попереднього бронювання номера, взаємодія з ними та надання лікувальних послуг. Оплата проживання і додаткових послуг здійснюється на основі виставленого рахунку. 
Обрана реляційна модель є достатньо ефективною, оскільки вона повністю задовольняє зручне і швидке виконання поставлених задач адміністратора профілакторію, а саме реєстрація клієнта у закладі з внесенням необхідних даних про нього, визначення знижки або її відсутності, терміну проживання та запис на певне лікування тощо. 
За кодом проживання ми можемо визначити обрані клієнтом лікувальні послуги, рахунки, які відносяться до даного проживання, знижку, номер кімнати, а відповідно і її тип, а також самого клієнта.
Зв’язки між таблицями в ER-діаграмі мають бути реалізованими з урахуванням усіх правил шляхом додавання зовнішніх ключей  до дочірніх таблиць, які посилаються на батьківські таблиці з відповідними первинними ключами.  
Для  зв’язку таблиці «Clients» з дочірньою «Habitations», було додано зовнішній ключ «ClientCode». Для «Rooms», залежної від таблиці «Room types», було додано поле «RoomTypeCode». 
В свою чергу «Rooms» пов’язана з «Habitations» через «RoomCode». Щоб встановити залежність «Selected services» від «Treatement» та «Habitations», у таблиці створено зовнішні ключі «TreatmentCode» і «HabitationCode» відповідно. 
Для зв’язку «Accounts» з двома іншими таблицями «Discounts» і «Habitations» були додані такі ключі як «DiscountCode» та «HabitationCode». Власне схема наведена на рис. 3.2.  

 
Рисунок 3.2 – Логічна схема бази даних

    Усі таблиці розроблено відповідно до реляційної моделі. Майже всі таблиці мають відношення «один-до-багатьох», за виключенням зв’язку між таблицями «User» та «User Statistics», що мають відношення «один-до-одного», оскільки в одного проживання може бути тільки один рахунок. Через функціональну залежність за допомогою ідентифікатора можна встановити відповідне значення іншого стовпця.
На прикладі зв’язку між цими таблицями можна добре побачити  дотримування трьох перших нормальних форм:
– за першою нормальною формою в таблицях на перетині будь-якого рядка та стовбця знаходиться атомарне значення. В нашому випадку це проявляється в тому, що наприклад, для кожної обраної лікувальної послуги створюється відповідний новий окремий запис із кількістю годин, замість того, щоб записувати послуги, що відповідають одному клієнту в одну клітинку через кому;
– за другою нормальною формою в базі даних кожен неключовий атрибут залежить від первинного ключа відношення. Наприклад, щоб отримати повну залежність усіх полей від ключового значення таблицю «Room types» було винесено окремо від «Rooms», так як один й той самий тип кімнати може бути зустрічатися у багатьох номерів. Тож такі залежності було виділено в окремі таблиці;
– за третьою нормальною формою атрибути повністю функціонально залежать від первинних ключів та між неключовими атрибутами немає транзитивних залежностей.  Таким чином всі неключові стовпці не дають можливості отримати дані з інших стовпців, а лише надають інформацію, яка в них міститься.
Так як всі таблиці в наведеній логічній схемі бази даних знаходяться в третій нормальній формі, то можна зробити висновок, що отримана база даних знаходиться в третій нормальній формі. 
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура серверної частини


Перед початком розробки сервера треба проаналізувати концептуальне моделювання предметної області. Користувачами серверної частини є 2 типи акторів: клієнт та адміністратор. 
 За допомогою програмного забезпечення клієнти повинні мати доступ до збереження, редагування власної інформації, перегляду її, а також статистики та бонусів щодо за їх внесок у переробку сміття. І звичайно перш за все, вони можуть здавати сміття в пунктах здачі у найбільш зручний спосіб і при цьому можливо переглянути найближчі до користувача точки прийому, включно за допомогою функцій пошуку та фільтрування.
Адміністратор же відповідає за підтримку працездатності програмної системи та редагування системних даних. Він має доступ до унікального функціоналу, до якого не мають інші користувачі, зокрема, у його розпорядженні є коригування логістичних та бізнес процесів, формувати звіти роботи підприємств, змінювати статус операцій тощо. Здатний переглядати усіх  користувачів, що зареєстровані у системі, пошук та сортування. Адміністратор може видалити користувача. Можливий перегляд інформації про всі проведені операції та їх редагування, має доступ до інших даних, що занесені до системи.
За допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних користувачів із системою (див. рис. 4.1).
 
Рисунок 4.1 – Діаграма прецедентів серверної частини програмної системи

Для створення програмного забезпечення було обрано наступні інструменти розробки:
−	Серверна частина написана на мові C# з використанням технології .NET ASP.NET Core Web API з використанням стилю REST [2];
−	База даних створена за допомогою технології MS SQL Server по принципу Code First, доступ до неї здійснюється з використанням технології Entity Framework Core.
Для кращої ілюстрації використаних технологій наведено діаграму розгортання, що описує архітектуру програми (див. рис. 4.2). 
 
Рисунок 4.2 – Діаграма розгортання серверної частини програмної системи

Система складається з 5 компонентів, а саме: веб серверу з API, веб-додатку, бази даних, мобільного застосунку та IoT-приладу. На сервері розміщується backend програмного продукту який містить більшу частину бізнес-логіки. Веб-додаток дозволяє користувачам взаємодіяти із системою та робити замовлення. Мобільний застосунок, що працює на Android, дозволяє користувачам реєструвати нові IoT прилади у системі. IoT прилад відправляє статистичні дані та видає замовлення.
Щоб переглядати та перевіряти ендпоінти API використовується Swagger, який дозволяє зручно проводити тестування API, покращуючи якість та зручність розробки. Для забезпечення безпеки даних та конфіденційності використовується захищений протокол HTTPS, що допомагає захистити дані під час їхньої передачі. 
Для автоматизації процесу мапування між об’єктами використано бібліотеку AutoMapper. Це дозволяє зменшити кількість одноманітного коду при роботі з об’єктами даних та спрощує розробку серверної частини. 
Для забезпечення маршрутизації запитів використанні API контролери, що є вбудованими засобами розробки на ASP .NET Core. Вони дозволяють розділити програму на логічні компоненти, кожен з яких відповідає за обробку конкретного виду запитів або дій користувача. Це спрощує керування кодом та його розширення. 
Розроблений серверний застосунок побудований відповідає принципам Чистої Архітектури та складається з BLL, DLL, CORE та Domain частин, які взаємодіють між собою [3]. 
Діаграма компонентів серверного застосунка представлена на діаграмі пакетів (див. рис. 4.3). 
 
Рисунок 4.3 – Діаграма компонентів серверної частини програмної системи

Приклади частин коду серверного застосунка представлено у додатку Б.
Отже, було визначено технології й архітектуру серверної частини програмної системи.


4.2 Архітектура IoT частини


Користувачами IoT частини розробленої системи є 2 типи акторів: адміністратор та клієнт.
Основними потребами клієнта є: здача сміття, визначення його ваги, отримання повідомлення з інформацією щодо здачі, реєстрація власного профілю для нарахування бонусів, а також перегляд статусу контейнера.
Основними потребами адміністратора є: можливість налаштування роботи пристрою, відстежування змін, редагування та збір даних, формування запиту на вивіз сміття, моніторинг стану контейнера, отримання повідомлень про помилки та збої в роботі системи.
Взаємодію кожної ролі користувачів з IoT частиною системи представлено на діаграмі прецедентів (див. додат. А.1). 
Таким чином, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.
 
Рисунок 4.4 – Діаграма прецедентів IoT частини програмної системи

Пристрій для IoT частини проєкту складається з мікроконтролера ESP32, ультразвукового датчика відстані HC-SR04, підсилювача тензодатчика HX711 на 50 кг, монохромного OLED-дисплею розміром 128x64 з інтерфейсом I2C, п’єзоелектричного гудка, трьох світлодіодів червоного, жовтого та зеленого кольору, одного RGB діоду та двох кнопок зеленого та червоного кольору відповідно (див. рис. 4.5).
 
Рисунок 4.5 – Будова пристрою для IoT частини програмної системи

Контролер ESP32 є центральним елементом пристрою, який керує всіма компонентами. Ультразвуковий датчик HC-SR04 використовується для вимірювання відстані і має чотири піни: VCC підключений до 3.3V ESP32, GND до GND ESP32, Trig до піну D23 ESP32 для надсилання ультразвукових імпульсів, а Echo до піну D22 ESP32 для приймання відбитих імпульсів.
Три світлодіоди служать для індикації різних станів пристрою: червоний світлодіод підключений до піну D19 ESP32, жовтий до піну D18 ESP32, а зелений до піну D5 ESP32. Катоди всіх світлодіодів з’єднані з GND через резистори для обмеження струму.
Зумер підключений до піну D4 ESP32, що дозволяє ESP32 керувати звуковими сигналами, тоді як інший його контакт з’єднаний з GND. OLED дисплей використовується для відображення інформації і має чотири піни: GND підключений до GND ESP32, VCC до 3.3V ESP32, SCL до піну D15 ESP32, а SDA до піну D14 ESP32, що забезпечує зв'язок через I2C інтерфейс.
Навантажувальний датчик підключений до підсилювача HX711, який дозволяє вимірювати вагу. HX711 має чотири піни для підключення до ESP32: GND до GND ESP32, VCC до 3.3V ESP32, DT до піну D13 ESP32 для передачі даних, а SCK до піну D12 ESP32 для синхронізації.
Дві кнопки використовуються для керування пристроєм. Зелена кнопка підключена до піну D21 ESP32, а червона кнопка до піну D19 ESP32. Інші контакти обох кнопок з’єднані з GND для завершення електричного кола.
Отож, так було визначено основні апаратні компоненти IoT частини проєкту.
Для написання IoT складової системи було обрано реалізацію мови програмування Python MicroPython для ESP32. У якості середовища розробки було обрано онлайн-платформу Wokwi.com, тому що вона представляє зручний безкоштовний симулятор смарт-пристроїв із усім необхідним функціоналом.
Для програмування різних частин мікроконтролера ESP32  були використані написані власноруч бібліотеки sonic_lib.py, oled_lib.py, hx711.py.
Для реалізації Wi-Fi функціоналу було також використано бібліотеки network, urequests, json тощо. 
Для більш детальної демонстрації використаних пакетів було розроблено діаграму пакетів (див. рис. 4.6).
 
Рисунок 4.6 – Діаграма пакетів IoT частини програмної системи

Бібліотека sonic_lib.py надає драйвер для використання ультразвукового сенсора HC-SR04 з мікроконтролерами, які підтримують MicroPython. Сенсор HC-SR04 використовується для вимірювання відстані до об'єкта за допомогою ультразвукових хвиль. Він має діапазон вимірювань від 2 см до 4 м.
Бібліотека oled_lib.py забезпечує функціонал для роботи з OLED дисплеями SSD1306 через інтерфейси I2C та SPI. Вона дозволяє ініціалізувати дисплей, налаштовувати контрастність, відображати текст, малювати пікселі та інші графічні операції. Клас SSD1306 містить основні функції для керування дисплеєм, а підкласи реалізують специфічні методи для роботи з I2C та SPI інтерфейсами відповідно. Бібліотека налаштовує дисплей, керує буфером кадрів і дозволяє відправляти команди та дані на дисплей для його оновлення.
Бібліотека hx711.py дозволяє взаємодіяти з аналогово-цифровим перетворювачем HX711, який використовується для зчитування даних з вагових датчиків. Вона забезпечує функції для ініціалізації датчика, зчитування даних, налаштування масштабування та калібрування (обнулення). Бібліотека також підтримує увімкнення та вимкнення живлення датчика.
Бібліотека network була використана для реалізації Wi-Fi підключення.
Бібліотеки urequests та json були імпортовані для успішного виконання http-запитів до сервера.
Програмна частина пристрою складається з кодової частини для мікроконтролера ESP32, основна частина якої знаходиться у файлі main.py, з якого і починається виконання програми. Вже з нього відбувається взаємодія з іншими класами системи, запити до сервера, імпорт бібліотек тощо.
Тип архітектури, розробленої IoT частини програмної системи, відноситься до периферійних обчислень (Edge Computing), оскільки основна обробка та прийняття рішень виконуються локально на пристрої (ESP32), а сервер використовується для додаткових функцій, таких як віддалений моніторинг та зберігання даних.
Взаємодія пристрою з користувачем починається з його увімкнення та підключається до Wi-Fi. Якщо підключення успішне, пристрій отримує дані про контейнер та починає вимір його заповненості. Якщо вільного місця в контейнері більше ніж 50 см заввишки, відбувається реєстрація клієнта, зважування сміття, реєстрація цієї операції, потім повертається до визначення заповненості баку та очікування нових відходів. Якщо менше ніж на 50 см, пристрій відправляє звукове та текстове повідомлення про переповненість сміттям, формує заявку на вивіз сміття та очікує звільнення контейнеру від нього. Відповідно, доки місце в ньому не з’явиться, клієнти не матимуть змоги користуватися сервісом. Це дозволяє автоматизувати процес управління відходами, ефективно керувати їх збором та транспортуванням за допомогою IoT пристрою.
На основі описаної взаємодії пристрою з користувачем було побудовано діаграму взаємодії (див. рис. 4.7).
 
Рисунок 4.7 – Діаграма взаємодії IoT частини програмної системи

Діяльність системи можна описати як взаємодію пристрою і серверної частини. Робота пристрою починається з його увімкнення, потім відбувається під’єднання до Wi-Fi та отримання конфігураційних даних із сервера. Після цього виконується нескінченний цикл, у я кому кожну ітерацію визначається відстань від датчика до сміття, тим самим дізнається наповненість контейнеру. Отримана величина перевіряється на відповідність вимогам: у разі перевищенні дистанції у 300 см, загоряється зелений світлодіод та виводиться повідомлення на дисплеї про неповний бак; якщо менше 300 см, але більше 50 см, то горить жовтий діод та повідомляється про часткову наповненість; у разі ж наявності вільного простору менше ніж 50 см, контейнер блокується та здача сміття стає неможливою, загоряється червоний діод та з’являється попередження про заповненість баку. Кожна зміна заповненості фіксується і викликає оновлення даних на сервері щодо стану баку. Доки сміття не буде вивезено, контейнером неможливо буде скористатися. Якщо ж вільне місце є, то утриманням зеленої кнопки за наявності профілю клієнт реєструється для здачі сміття. Після успішної авторизації загоряється зелений діод, що означає дозвіл на проведення здачі сміття і пропонується його внесення. Коли весь необхідний обсяг відходів внесено, клієнт має натиснути червону кнопку, що  викликає  зважування, результат якого, а також нараховані бонуси за нього виводяться на екран. На сервер відправляється інформація про операцію.
Спираючись на описану діяльність пристрою було побудовано діаграму діяльності, що відображає взаємодію пристрою з сервером (див. рис. 4.8). 
 
Рисунок 4.8 – Діаграма діяльності IoT частини програмної системи

Отож, за допомогою діаграм пакетів, взаємодії та діяльності було визначено основні технології та архітектуру системи. 
Приклади коду IoT частини системи для мікроконтролера ESP32 представлено у додатку В.1. 
Приклади коду бібліотеки IoT частини системи для пристрою HC-SR04 представлено у додатку В.2.


4.3 Архітектура клієнтської частини


Користувачами клієнтської частини розробленої системи є 2 типи акторів: адміністратор та клієнт.
Основними потребами клієнта є в першу чергу можливість перегляду точок прийому сміття на мапі, їх стану, характеристики та заповненості, а також перегляд особистої інформації, її редагування, видалення акаунту за потреби, доступ до накопичених бонусів, переліку виконаних операції зі здачі сміття тощо.
Основними потребами адміністратора є: можливість перегляду користувачів системи та керування ними; можливість створення, редагування та видалення будь-яких даних у системі; можливість зручного перегляду всіх збережених даних, використання сортування; формування та завантаження звіту щодо роботи конкретної точки збору; можливість створення резервних копій даних системи та їхній імпорт в систему.
Взаємодію обох ролей користувачів з клієнтською частиною системи представлено на діаграмі прецедентів (див. рис. 4.10).
 
Рисунок 4.10 – Діаграма прецедентів клієнтської частини програмної системи

Відповідно, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.
Для написання клієнтської частини системи було обрано мову програмування JavaScript з використанням технології React, що дозволяє забезпечити високу швидкість розробки і зручність у використанні за рахунок можливостей бібліотеки, управління станами та компонентного підходу [4]. 
Щоб реалізувати елементи інтерфейсу було використано бібліотеки react-bootstrap і reactstrap, які надають готові шаблони стилів для елементів інтерфейсу для швидкої і зручної розробки гарно оформленого, і відповідно, візуально привабливого веб-додатку.
Для реалізації відображення місцезнаходження точок збору було використано бібліотеку MapBox GL, яка забезпечує великі можливості географічної візуалізації та взаємодії з картографічними об’єктами для створення динамічних та інтерактивних карт.
Для реалізації локалізації інтерфейсу було використано бібліотеку i18next, яка дозволяє легко і ефективно забезпечити багатомовний інтерфейс та пропонує зручний механізм перекладу тексту.
Для виконання навігації по сайту використано бібліотеку react-router-dom, яка надає зручні та гнучкі інструменти для створення навігації та управління маршрутами веб-застосунку.
Для зручного вибору відтинку часу було використано пакет react-datepicker завдяки приємному інтерфейсу, який він забезпечує.
Для візуалізації використаних пакетів було розроблено діаграму пакетів (див. рис. 4.11).
 
Рисунок 4.11 – Діаграма пакетів клієнтської частини програмної системи

Клієнтську частину було розроблено за допомогою Feature-Based File Structure архітектури [5]. Вона організує код за функціональними областями та типами компонентів, що спрощує навігацію та підтримку коду, а кожен тип сутностей має власну папку.
Такий підхід забезпечує хорошу організованість і масштабованість React-додатка, дозволяючи легко додавати нові елементи, зберігаючи при цьому ясність і структуру коду. Файли і папки організовані таким чином: в корені проекту знаходяться папки public і src, де public містить статичні файли, такі як index.html. Папка src містить весь вихідний код додатка. Тут розташовані папки assets для статичних ресурсів (зображення, стилі), components для компонентів додатка, де спільні компоненти зберігаються в common, а специфічні в specific. Хуки зберігаються в папці hooks, контексти для управління глобальним станом - у папці contexts, а сервіси для роботи з API та бізнес-логікою - у папці services. Компоненти сторінок зберігаються в pages, маршрути додатка - в routes, а утиліти та допоміжні функції - в utils. Основні файли додатка, такі як App.js та index.js, розташовані безпосередньо в папці src.
Для кращого розуміння архітектури системи було розроблено діаграму компонентів (див. рис. 4.12).
 
Рисунок 4.12 – Діаграма компонентів клієнтської частини програмної системи

Користувач починає взаємодіяти з клієнтською частиною з введення даних профілю (під час реєстрації або входу). Після авторизації, відповідно до ролі  користувача, взаємодія поділяється на клієнтську та адміністраторську.
Якщо користувач є клієнтом, він може переглядати точки збору на мапі та інформацію про них, відстежувати їх стан у реальному часі. За допомогою інструментів пошуку може знайти для нього найбільш підходящий для нього варіант. У разі необхідності, клієнт може оновлювати власні дані, редагувати профіль або взагалі видалити акаунт. Крім того, клієнту доступні операції зі здачі сміття, у яких він брав участь.
Якщо користувач є адміністратором, він має доступ до панелі адміністратора, з якої він може імпортувати та експортувати дані системи, переглядати збережені дані, здійснювати керування ними, включаючи редагування, видалення, додавання нової інформації та управління користувачами, а також формувати звіти про роботу точок прийому за певний період. 
Для більш детального відображення взаємодії користувачів з клієнтської частиною системи було розроблено діаграму взаємодії (див. рис. 4.13).
 
Рисунок 4.13 – Діаграма взаємодії клієнтської частини програмної системи

Отже, за допомогою діаграм пакетів, компонентів та взаємодії було визначено основні технології та архітектуру системи.
Приклади коду клієнтської частини системи представлено у додатку Г
 
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження


Для виклику програми необхідно завантажити архів, у якому вона знаходиться, та розархівувати її. Оскільки у програмному продукті використовується з’єднання із СУБД Microsoft SQL Server Express, необхідно встановити її останню версію з офіційного сайту виробника. 
Щоб забезпечити з’єднання застосунку з базою даних, потрібно відкрити файл appsettings.json за шляхом «apzkr-pzpi-21-1-salamatov-oleksii/Task1-Server/Smart Recycling» та змінити значення рядку «DefaultConnection» на власну строку підключення до бази даних.
Далі необхідно запустити серверну частини системи. Для цього можна використати засоби середовища розробки Visual Studio, яку необхідно завантажити з офіційного сайту виробника. Відкривши SmartRecyclingAPI.sln у теці «apzkr-pzpi-21-1-salamatov-oleksii/Task1-Server», треба натиснути на «Start Without Debugging» у верхній панелі.
Тепер потрібно запустити клієнтську частину системи і для цього можна скористатися, наприклад Visual Studio Code, яку можна завантажити з офіційного сайту. Відкривши директорію «apzkr-pzpi-21-1-salamatov-oleksii/apzkr-pzpi-21-1-salamatov-oleksii/Task3-WebClient» у середовищі розробки, необхідно прописати команду «npm run start» у терміналі та натиснути клавішу «Enter», після чого запуститься вебклієнт.
Для запуску IoT частини необхідно відкрити онлайн-платформу Wokwi.com та створити проєкт з усіма файлами з директорії «apzkr-pzpi-21-1-salamatov-oleksii/Task2-IoT», після цього натиснути зелену кнопку «Start the simulation».


5.2 Призначення і логічна структура



Функції, які може виконувати програма, можна виділити в декілька модулів, а саме:
	авторизація та реєстрація;
	керування пунктами прийому;
	управління користувачами;
	статистика та звіти;
	дані системи;
Модуль «Авторизація та реєстрація» містить у собі функції для входу в систему та створення нового облікового запису. 
Модуль «Керування пунктами прийому» дозволяє додавати та редагувати інформацію про пункти прийому сміття та переглядати статус і заповненість пунктів прийому на інтерактивній мапі.
Модуль «Статистика та звіти» надає можливість отримувати аналітичні дані про діяльність системи, містить функції для генерації статистики та формування звітів.
Модуль «Управління користувачами» є адміністраторським, і містить у собі функції для керування користувачами системи.
Модуль «Дані системи» є адміністраторським, і містить у собі функції для додавання, збереження, редагування, видалення, а також для експорту та імпорту даних системи.


5.3 Опис програмної реалізації


При відкритті клієнтського застосунка можна побачити головну сторінку (див. рис. 5.2). Повернутися до неї можна за допомогою натискання пункту меню «Home» або назви системи «Smart Recycling».
     З неї можна перейти до сторінки авторизації, а також налаштувати локалізацію сайту, натиснувши на символ локалізації, який розташовано у футері у правому боці. На вибір доступні англійська та українська мови. На сайті також присутня інтернаціоналізація, що залежить від регіону браузера.
 
Рисунок 5.2 – Головна сторінка сайту

У хедері сайту доступні кнопка для авторизації «Log in» та реєстрації «Sign up». На сторінці авторизації потрібно ввести електронну пошту та пароль (див. рис. 5.3).
 
Рисунок 5.3 – Сторінка авторизації

При створенні нового облікового запису потрібно вказати ім’я, прізвище, роль, електронну пошту та пароль (див. рис. 5.4).
 
Рисунок 5.4 – Сторінка реєстрації

Всім користувачам при переході до пункту меню «Our Points» доступна сторінка для перегляду статусу та заповненості пунктів прийому, їх місцезнаходження на мапі.

 
Рисунок 5.5 – Сторінка пунктів прийому сміття

Після авторизації у хедері з’являється кнопка «Me» для керування своїм акаунтом.
У разі авторизації як клієнт на сторінці профілю доступні поля з його персональними даними з можливістю їх редагування, а також інформація щодо переробленого сміття, нарахованих бонусів, операцій, у яких клієнт брав участь (див. рис. 5.6). За потреби є можливість видалити акаунт.
 
Рисунок 5.6 – Сторінка профілю клієнта

При авторизації як адміністратор доступно лише частина полей власних даних та можливість редагування (див. рис. 5.7).
 
Рисунок 5.7 – Сторінка профілю адміністратора

Крім того, адміністратору доступна панель адміністрування при натисканні на «Data» у меню. На ній він може переглядати всі збережені дані, додавати нові, редагувати та видаляти існуючі (див. рис. 5.9). Наявні таблиці «Користувачі», «Операції» «Пункти прийому», «Транспортування», «Точки переробки». До того ж на цій сторінці можна імпортувати та експортувати дані бази даних за допомогою кнопок «Import Data» та «Export Data».
 
Рисунок 5.8 – Сторінка адміністрування системи з таблицею користувачів

При виборі таблиці «Пункти прийому» можливо переглянути кожен пункт більш детально при натисканні на «Деталі» навпроти кожного з них у таблиці (див. рис. 5.9).
 
Рисунок 5.9 – Сторінка адміністрування системи з таблицею пунктів прийому

Після переходу до інформаційної сторінки конкретного пункту прийому бачимо детальну інформацію про нього, його поточний статус, зміст, заповненінсть (див. рис. 5.10). На цій же сторінці можна отримати звіт із статистикою щодо його роботи за обраний період часу після натискання кнопки «Отримати звіт».
 
Рисунок 5.10 – Сторінка перегляду пункту прийому

Наявна можливість редагування його даних або взагалі його повного видалення (див. рис. 5.11). Після внесення змін необхідно натиснути кнопку «Зберегти».
 
Рисунок 5.11 – Сторінка редагування пункту прийому

При редагуванні операцій відкривається pop-up вікно у якому можна внести всі необхідні зміни (див. рис. 5.12).
 
Рисунок 5.12 – Вікно редагування операції

Таким чином, було описано можливості взаємодії користувача з розробленою програмною системою.
Запис результатів функціонального тестування доступний за посиланням: https://rb.gy/ez7f2i (дата звернення: 17.06.2024). 
ВИСНОВКИ


За результатами виконання роботи було розроблено програмну систему на основі предметної області «Контроль здачі та переробки сміття».
     У процесі роботи було проаналізовано предметну область, спроектовано структуру бази даних, розроблено архітектуру серверної, IoT та клієнтської частин програмної системи та реалізовано її програмними засобами ASP.NET Core, MicroPython та React.js.
     Розроблена програмна система дозволяє користувачам зручно знаходити пункти прийому відходів, здавати і сортувати сміття, отримуючи вигоду з цього. Вона забезпечує реєстрацію та авторизацію користувачів, керування власною інформацією. Система забезпечує моніторинг статусу пунктів прийому та точок переробки сміття у режимі реального часі, управління ними, відстеження транспортування відходів. Також, в системі наявні можливості адміністрування, такі як: керування користувачами системи, керування даними та налаштуваннями системи, експорт та імпорт даних.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	SQL Server technical documentation. URL: https://learn.microsoft.com/en-us/sql/sql-server/?view=sql-server-ver16 (дата звернення 18.06.2024).
2.	ASP.NET documentation. URL: https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0 (дата звернення 18.06.2024).
3.	Three Tier Architecture In ASP.NET Core 6 Web API. URL: https://www.c-sharpcorner.com/article/three-tier-architecture-in-asp-net-core-6-web-api/ (дата звернення 18.06.2024).
4.	React Reference Overview. URL: https://react.dev/reference/react (дата звернення 18.06.2024).
5.	Part 2: Folder Structure - Building a Solid Foundation. URL: https://dev.to/sathishskdev/part-2-folder-structure-building-a-solid-foundation-omh (дата звернення 18.06.2024).
 
ДОДАТОК А 
Результат перевірки на плагіат


Рисунок А.1 – Результат перевірки на плагіат
 
ДОДАТОК Б 
Програмний код серверної частини
Б.1 Код основного файлу для роботи сервера Program.cs:


1.	using using Microsoft.AspNetCore.Authentication.JwtBearer;
2.	using Microsoft.AspNetCore.Authorization;
3.	using Microsoft.EntityFrameworkCore;
4.	using Microsoft.IdentityModel.Tokens;
5.	using Microsoft.OpenApi.Models;
6.	using DAL.Contexts;
7.	using System.Text;
8.	using System.Text.Json.Serialization;
9.	using SmartRecyclingAPI;
10.	using BLL.Services;
11.	
12.	var builder = WebApplication.CreateBuilder(args);
13.	
14.	string? connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
15.	
16.	//authentication
17.	builder.Services.AddAuthentication(options =>
18.	{
19.	    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
20.	    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
21.	})
22.	    .AddJwtBearer(options =>
23.	    {
24.	        options.TokenValidationParameters = new TokenValidationParameters
25.	        {
26.	            ValidateIssuer = true,
27.	            ValidateAudience = true,
28.	            ValidateLifetime = true,
29.	            ValidateIssuerSigningKey = true,
30.	
31.	            ValidIssuer = "https://localhost:7051",
32.	            ValidAudience = "https://localhost:7051",
33.	            IssuerSigningKey = new SymmetricSecurityKey(Encoding.ASCII
34.	            .GetBytes("mysupersecret_secretkey!@@@123456"))
35.	        };
36.	    });
37.	
38.	builder.Services.AddAuthorization(options =>
39.	{
40.	    options.DefaultPolicy = new AuthorizationPolicyBuilder(JwtBearerDefaults.AuthenticationScheme)
41.	    .RequireAuthenticatedUser()
42.	    .Build();
43.	});
44.	
45.	// Add services to the container.
46.	
47.	//builder.Services.AddTransient<Seed>();
48.	
49.	builder.Services.AddControllers(options =>
50.	{
51.	    options.InputFormatters.Insert(0, MyJPIF.GetJsonPatchInputFormatter());
52.	})
53.	    .AddJsonOptions(options =>
54.	    {
55.	        options.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles;
56.	    });
57.	
58.	builder.Services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());
59.	
60.	// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
61.	builder.Services.AddEndpointsApiExplorer();
62.	builder.Services.AddSwaggerGen(c => {
63.	    c.AddSecurityDefinition("Bearer", securityScheme: new OpenApiSecurityScheme
64.	    {
65.	        Name = "Authorization",
66.	        Description = "Enter the Bearer Authorization string",
67.	        In = ParameterLocation.Header,
68.	        Type = SecuritySchemeType.Http,
69.	        Scheme = "Bearer",
70.	        BearerFormat = "JWT"
71.	    });
72.	    c.AddSecurityRequirement(new OpenApiSecurityRequirement
73.	    {
74.	        {
75.	            new OpenApiSecurityScheme
76.	            {
77.	                Reference = new OpenApiReference
78.	                {
79.	                    Type=ReferenceType.SecurityScheme,
80.	                    Id="Bearer"
81.	                }
82.	            },
83.	            new string[]{}
84.	        }
85.	    });
86.	});
87.	
88.	builder.Services.AddDbContext<SmartRecyclingDbContext>(options => options.UseSqlServer(connectionString));
89.	
90.	builder.Services.AddScoped<AuthService>();
91.	builder.Services.AddScoped<PointStateService>();
92.	builder.Services.AddScoped<TransportationService>();
93.	
94.	builder.Services.AddCors(options =>
95.	{
96.	    options.AddDefaultPolicy(policy =>
97.	    {
98.	        policy.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader();
99.	    });
100.	});
101.	
102.	var app = builder.Build();
103.	
104.	// Configure the HTTP request pipeline.
105.	if (app.Environment.IsDevelopment())
106.	{
107.	    app.UseSwagger();
108.	    app.UseSwaggerUI();
109.	}
110.	
111.	app.UseCors();
112.	
113.	app.UseHttpsRedirection();
114.	
115.	app.UseAuthentication();
116.	
117.	app.UseAuthorization();
118.	
119.	app.MapControllers();
120.	
121.	app.Run();


В.2 Код для формування статистики та звітів


1.	using iTextSharp.text.pdf;
2.	using iTextSharp.text;
3.	using Document = iTextSharp.text.Document;
4.	using DAL.Contexts;
5.	using CORE.Models;
6.	using System.Web.Mvc;
7.	
8.	namespace BLL.Services
9.	{
10.	    public class StatisticsService: BaseService
11.	    {
12.	        public StatisticsService(SmartRecyclingDbContext smartRecyclingDbContext) : base(smartRecyclingDbContext)
13.	        {
14.	        }
15.	
16.	        public CollectionPointStatistics CreatePointStatistics(int point, DateOnly startDate, DateOnly endDate)
17.	        {
18.	            List<Operation> operations = dbContext.Operation
19.	                .Where(o => o.CollectionPointID == point && DateOnly.FromDateTime(o.Time) >= startDate && DateOnly.FromDateTime(o.Time) <= endDate)
20.	                .ToList();
21.	
22.	            CollectionPointStatistics collectionPointStatistics = new()
23.	            {
24.	                Collected = operations.Sum(o => o.Weight),
25.	                Recycled = 0,
26.	                MostCollectedType = operations
27.	                    .GroupBy(o => o.TrashType)
28.	                    .OrderByDescending(g => g.Sum(o => o.Weight))
29.	                    .Select(g => g.Key)
30.	                    .FirstOrDefault(),
31.	                Attendance = operations.Select(o => o.UserID).Count(),
32.	                Period = startDate.ToString() + '-' + endDate.ToString(),
33.	                CollectionPointID = point
34.	            };
35.	
36.	            return collectionPointStatistics;
37.	        }
38.	
39.	        public byte[] GeneratePdfContent(CollectionPointStatistics pointStatistics)
40.	        {
41.	
42.	            using (var ms = new MemoryStream())
43.	            {
44.	                using (var doc = new Document())
45.	                {
46.	                    PdfWriter.GetInstance(doc, ms);
47.	                    doc.Open();
48.	                    doc.Add(new Paragraph($"Report"));
49.	                    doc.Close();
50.	                }
51.	                return ms.ToArray();
52.	            }
53.	        }
54.	
55.	        public async void UpdateUserStatistics(Operation operation)
56.	        {
57.	            var statistics = await dbContext.UserStatistics.FindAsync(operation.UserID);
58.	            statistics.Recycled += operation.Weight;
59.	            Dictionary<string, double> bonusRate = new Dictionary<string, double>()
60.	            {
61.	                { "glass", 0.05 },
62.	                { "plastic", 0.03 },
63.	                { "paper", 0.02 },
64.	                { "metal", 0.08 }
65.	            };
66.	
67.	            statistics.Bonuses += Convert.ToInt32(Math.Round(operation.Weight * bonusRate[operation.TrashType]));
68.	            await dbContext.SaveChangesAsync();
69.	        }
70.	
71.	        public FileStreamResult GetFile(CollectionPointStatistics statistics)
72.	        {
73.	            byte[] pdfBytes = GeneratePdfContent(statistics);
74.	            MemoryStream stream = new MemoryStream(pdfBytes);
75.	            stream.Position = 0;
76.	
77.	            return new FileStreamResult(stream, "application/pdf")
78.	            {
79.	                FileDownloadName = $"report-for:{statistics.Period}.pdf"
80.	            };
81.	        }
82.	    }
83.	}


В.3 Код для обробки авторизації


1.	using CORE.Models;
2.	using DAL.Contexts;
3.	using Microsoft.IdentityModel.Tokens;
4.	using System.IdentityModel.Tokens.Jwt;
5.	using System.Security.Claims;
6.	using System.Security.Cryptography;
7.	using System.Text;
8.	
9.	namespace BLL.Services
10.	{
11.	    public class AuthService: BaseService
12.	    {
13.	        public AuthService(SmartRecyclingDbContext smartRecyclingDbContext) : base(smartRecyclingDbContext)
14.	        {
15.	        }
16.	
17.	        public dynamic GetResponse(string email, string password, ClaimsIdentity identity)
18.	        {
19.	            var key = new SymmetricSecurityKey(
20.	                Encoding.ASCII
21.	                .GetBytes("mysupersecret_secretkey!@@@123456"));
22.	
23.	            var now = DateTime.UtcNow;
24.	            var jwt = new JwtSecurityToken(
25.	                    issuer: "https://localhost:7051",
26.	                    audience: "https://localhost:7051",
27.	                    claims: identity.Claims,
28.	                    expires: now.Add(TimeSpan.FromMinutes(5)),
29.	                    signingCredentials: new SigningCredentials(key, SecurityAlgorithms.HmacSha256));
30.	            var encodedJwt = new JwtSecurityTokenHandler().WriteToken(jwt);
31.	
32.	            var response = new
33.	            {
34.	                access_token = encodedJwt,
35.	                email = identity.Name,
36.	            };
37.	
38.	            return response;
39.	        }
40.	
41.	        public ClaimsIdentity GetIdentity(string email, string? password)
42.	        {
43.	            User? user = dbContext.User.FirstOrDefault(x => x.Email == email/* && x.Password == password*/);
44.	            if (user != null)
45.	            {
46.	                var claims = new List<Claim>
47.	                {
48.	                    new Claim(ClaimsIdentity.DefaultNameClaimType, user.Email),
49.	                    new Claim(ClaimsIdentity.DefaultRoleClaimType, user.Role),
50.	                    new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString())
51.	                };
52.	
53.	                ClaimsIdentity claimsIdentity =
54.	                new ClaimsIdentity(claims, "Token", ClaimsIdentity.DefaultNameClaimType,
55.	                    ClaimsIdentity.DefaultRoleClaimType);
56.	                return claimsIdentity;
57.	            }
58.	
59.	            return null;
60.	        }
61.	
62.	        public static string HashPassword(string password)
63.	        {
64.	            byte[] salt;
65.	            byte[] buffer2;
66.	            if (password == null)
67.	            {
68.	                throw new ArgumentNullException("password");
69.	            }
70.	            using (Rfc2898DeriveBytes bytes = new(password, 0x10, 0x3e8))
71.	            {
72.	                salt = bytes.Salt;
73.	                buffer2 = bytes.GetBytes(0x20);
74.	            }
75.	            byte[] dst = new byte[0x31];
76.	            Buffer.BlockCopy(salt, 0, dst, 1, 0x10);
77.	            Buffer.BlockCopy(buffer2, 0, dst, 0x11, 0x20);
78.	            return Convert.ToBase64String(dst);
79.	        }
80.	
81.	        public static bool VerifyHashedPassword(string hashedPassword, string password)
82.	        {
83.	            byte[] buffer4;
84.	            if (hashedPassword == null)
85.	            {
86.	                return false;
87.	            }
88.	            if (password == null)
89.	            {
90.	                throw new ArgumentNullException("password");
91.	            }
92.	            byte[] src = Convert.FromBase64String(hashedPassword);
93.	            if ((src.Length != 0x31) || (src[0] != 0))
94.	            {
95.	                return false;
96.	            }
97.	            byte[] dst = new byte[0x10];
98.	            Buffer.BlockCopy(src, 1, dst, 0, 0x10);
99.	            byte[] buffer3 = new byte[0x20];
100.	            Buffer.BlockCopy(src, 0x11, buffer3, 0, 0x20);
101.	            using (Rfc2898DeriveBytes bytes = new Rfc2898DeriveBytes(password, dst, 0x3e8))
102.	            {
103.	                buffer4 = bytes.GetBytes(0x20);
104.	            }
105.	            return buffer3.SequenceEqual(buffer4);
106.	        }
107.	    }
108.	}


В.4 Код UserController.cs


1.	using AutoMapper;
2.	using BLL.Services;
3.	using CORE.Models;
4.	using DAL.Contexts;
5.	using Microsoft.AspNetCore.Mvc;
6.	using Microsoft.EntityFrameworkCore;
7.	using SmartRecycling.Dto;
8.	using QRCoder;
9.	
10.	namespace SmartRecycling.Controllers
11.	{
12.	    [ApiController]
13.	    [Route("api/[controller]/[action]")]
14.	    public class UserController : Controller
15.	    {
16.	        private readonly SmartRecyclingDbContext dbContext;
17.	        private readonly IMapper _mapper;
18.	
19.	        public UserController(SmartRecyclingDbContext dbContext, IMapper mapper)
20.	        {
21.	            this.dbContext = dbContext;
22.	            _mapper = mapper;
23.	        }
24.	
25.	        [HttpGet("{id}")]
26.	        public async Task<ActionResult<User>> GetUser(int id)
27.	        {
28.	            try
29.	            {
30.	                IQueryable<User> query = dbContext.User
31.	                    .Include(u => u.UserStatistics)
32.	                    .Include(u => u.Operations);
33.	
34.	                var user = await query.FirstOrDefaultAsync(c => c.Id == id);
35.	
36.	                if (user == null)
37.	                {
38.	                    return NotFound();
39.	                }
40.	
41.	                return Ok(user);
42.	            }
43.	            catch (Exception ex)
44.	            {
45.	                return StatusCode(500, "Internal server error");
46.	            }
47.	        }
48.	
49.	        [HttpPost]
50.	        public async Task<IActionResult> CreateUser(UserDto user)
51.	        {
52.	            var existingUser = await dbContext.User.Where(u => u.Email == user.Email).FirstOrDefaultAsync();
53.	            if (existingUser != null)
54.	            {
55.	                ModelState.AddModelError("", "User with such email already exists");
56.	                return StatusCode(422, ModelState);
57.	            }
58.	
59.	            var userMap = _mapper.Map<User>(user);
60.	            userMap.Password = AuthService.HashPassword(userMap.Password);
61.	
62.	            await dbContext.User.AddAsync(userMap);
63.	            await dbContext.SaveChangesAsync();
64.	
65.	            return Ok(user);
66.	        }
67.	
68.	        [HttpPut]
69.	        public async Task<IActionResult> UpdateUser([FromRoute] int id, [FromBody] UserDto updatedUserDto)
70.	        {
71.	            if (updatedUserDto == null || id != updatedUserDto.Id)
72.	                return BadRequest(ModelState);
73.	
74.	            var existingUser = await dbContext.User.FindAsync(id);
75.	
76.	            if (existingUser == null)
77.	                return NotFound();
78.	
79.	            _mapper.Map(updatedUserDto, existingUser);
80.	
81.	            try
82.	            {
83.	                await dbContext.SaveChangesAsync();
84.	            }
85.	            catch (DbUpdateConcurrencyException)
86.	            {
87.	                if (!dbContext.User.Any(e => e.Id == id))
88.	                {
89.	                    return NotFound();
90.	                }
91.	                else
92.	                {
93.	                    throw;
94.	                }
95.	            }
96.	
97.	            return NoContent();
98.	        }
99.	
100.	        [HttpDelete("{id}")]
101.	        public async Task<IActionResult> DeleteUser(int id)
102.	        {
103.	            var userToDelete = await dbContext.User.FindAsync(id);
104.	            if (userToDelete == null) 
105.	                return NotFound();
106.	
107.	            dbContext.User.Remove(userToDelete);
108.	            await dbContext.SaveChangesAsync();
109.	
110.	            return Ok();
111.	        }
112.	
113.	        [HttpGet("{userId}")]
114.	        public ActionResult GenerateQRCode(int userId)
115.	        {
116.	            QRCodeGenerator qrGenerator = new QRCodeGenerator();
117.	            QRCodeData qrCodeData = qrGenerator.CreateQrCode($"User Id: {userId}", QRCodeGenerator.ECCLevel.Q);
118.	            PngByteQRCode qrCode = new PngByteQRCode(qrCodeData);
119.	            byte[] qrCodeImage = qrCode.GetGraphic(20);
120.	            return File(qrCodeImage, "image/png");
121.	        }
122.	    }
123.	}

 
ДОДАТОК В 
Програмний код IoT пристрою
В.1 Код основного файлу main.py для роботи мікроконтролера ESP32


1.	# Import libraries
2.	import sonic_lib, oled_lib, machine
3.	from machine import Pin, SoftI2C, PWM
4.	from utime import sleep
5.	from hx711 import HX711
6.	from server_requests import get_data_from_server, post_data_to_server
7.	import network
8.	
9.	# Pin declaration 
10.	trig = Pin(13, Pin.OUT)
11.	echo = Pin(12, Pin.IN)
12.	
13.	buzzer = Pin(21, Pin.OUT)
14.	
15.	pin_oled = SoftI2C(scl=Pin(15), sda=Pin(2))
16.	
17.	green_led = Pin(25, Pin.OUT)
18.	yellow_led = Pin(26, Pin.OUT)
19.	red_led = Pin(27, Pin.OUT)
20.	
21.	red = Pin(23, Pin.OUT)
22.	green = Pin(22, Pin.OUT)
23.	red.value(0)
24.	green.value(1)
25.	button1 = machine.Pin(19, machine.Pin.IN, machine.Pin.PULL_UP)
26.	button2 = machine.Pin(18, machine.Pin.IN, machine.Pin.PULL_UP)
27.	button1_pressed = False
28.	
29.	capteur_hx711 = HX711(33, 32, 1)
30.	
31.	# Create name for libraries
32.	screen = oled_lib.SSD1306_I2C(width=128, height=64, i2c=pin_oled)
33.	jarak = sonic_lib.HCSR04(trigger_pin=trig, echo_pin=echo)
34.	
35.	# Global variables
36.	user_id = 0
37.	trash_type = ''
38.	collection_point_id = 0
39.	max_volume = 0
40.	bin_height = 200
41.	ssid = 'Wokwi-GUEST'
42.	server_url = "http://host.wokwi.internal:5048/"
43.	condition = False
44.	
45.	def connect_wifi(ssid):
46.	    wlan = network.WLAN(network.STA_IF)
47.	    wlan.active(True)
48.	    wlan.connect(ssid)
49.	    max_attempts = 10
50.	    attempt = 0
51.	
52.	    while not wlan.isconnected() and attempt < max_attempts:
53.	        print(f"Attempt {attempt+1} to connect to Wi-Fi")
54.	        sleep(1)
55.	        attempt += 1
56.	
57.	    if wlan.isconnected():
58.	        print('Connected to Wi-Fi')
59.	        print('Network config:', wlan.ifconfig())
60.	    else:
61.	        print('Failed to connect to Wi-Fi')
62.	        raise RuntimeError('Wi-Fi connection failed')
63.	
64.	def get_weight():
65.	    capteur_hx711.power_on()
66.	    while capteur_hx711.is_ready():
67.	        pass
68.	
69.	    measure = capteur_hx711.read(False)
70.	
71.	    while capteur_hx711.is_ready():
72.	        pass
73.	    measure = capteur_hx711.read(True)
74.	
75.	    # Calibration
76.	    measure = measure / 420
77.	    return measure
78.	
79.	def define_fullness(distance):
80.	    return round((1 - distance / bin_height) * 100)
81.	
82.	def get_trash_volume(prev_distance, new_distance):
83.	    trash_height = prev_distance - new_distance
84.	    return max_volume * (trash_height / bin_height)
85.	
86.	# Attempt to connect to Wi-Fi
87.	try:
88.	    connect_wifi(ssid)  # Connect to Wi-Fi
89.	except RuntimeError as e:
90.	    print(e)
91.	
92.	# Main Program
93.	while True:
94.	    # Ultrasonic program
95.	    distance_in_cm = jarak.distance_cm()
96.	    print('A garbage has been detected within:', distance_in_cm, 'cm')
97.	
98.	    # OLED, Buzzer & Led 
99.	    screen.fill(1)
100.	    if distance_in_cm > 120:
101.	        for a in range(10):
102.	            Buzzer = PWM(buzzer, freq=1500, duty=0)
103.	            green_led.on()
104.	            yellow_led.off()
105.	            red_led.off()
106.	
107.	            screen.text('NOT FULL YET', 20, 5, 0)
108.	
109.	    elif 50 <= distance_in_cm < 120:
110.	        for a in range(10):
111.	            Buzzer = PWM(buzzer, freq=1500, duty=0)
112.	            green_led.off()
113.	            yellow_led.on()
114.	            red_led.off()
115.	
116.	            screen.text('HALF THERE', 25, 5, 0)  
117.	
118.	    else:
119.	        for a in range(10):
120.	            green_led.off()
121.	            yellow_led.off()
122.	            red_led.on()
123.	
124.	            Buzzer = PWM(buzzer, freq=1500, duty=50)
125.	            sleep(0.5)
126.	            Buzzer = PWM(buzzer, freq=1500, duty=0)
127.	            sleep(0.5)
128.	
129.	            screen.text('BIN IS FULL,', 25, 15, 0)  
130.	            screen.text('PLS EMPTY', 30, 30, 0)
131.	    screen.text(f'Fullness: {str(define_fullness(distance_in_cm))}%', 12, 50, 0)    
132.	    screen.show()
133.	
134.	    if button1_pressed == False and distance_in_cm > 50:
135.	        for a in range(15):
136.	            screen.text('Hold green', 15, 30, 0)
137.	            screen.text('button to start', 1, 40, 0)
138.	            screen.show()
139.	
140.	    if distance_in_cm >= 50 :
141.	        prev_distance = 
142.	        if button1.value() == 0:
143.	            screen.fill(1)
144.	            print('Enter user id')
145.	            user_id = input()
146.	            print('Enter trash type')
147.	            trash_type = input()
148.	            green.value(0)
149.	            red.value(1)
150.	            while button2.value() == 1:
151.	                screen.text('Place the trash', 5, 20, 0)
152.	                screen.text('Press red', 15, 38, 0)
153.	                screen.text('button to finish', 1, 48, 0)
154.	                screen.show()
155.	        if button2.value() == 0:
156.	            red.value(0)
157.	            green.value(1)
158.	            weight = get_weight()
159.	            print("Total Weight is:", weight)
160.	            data_to_send = {
161.	                "trashType": trash_type,
162.	                "weight": weight,
163.	                "volume": get_trash_volume(distance_in_cm, jarak.distance_cm()),
164.	                "userID": user_id,
165.	                "collectionPointID": collection_point_id
166.	            }
167.	
168.	            # response = post_data_to_server(f'{server_url}api/Operation/CreateOperation', data_to_send)
169.	            # if response:
170.	            #     print("Response from server:", response)
171.	            # else:
172.	            #     print("Failed to post data")
173.	            for a in range(10):
174.	                screen.fill(1)
175.	                screen.text(f'Weight: {weight:.2f} kg', 15, 40, 0)
176.	                screen.show()
177.	        
178.	
179.	    sleep(0.5)


В.2 Код для формування статистики та звітів


1.	from machine import Pin, time_pulse_us
2.	from utime import sleep_us
3.	
4.	class HCSR04:
5.	    """
6.	    Driver to use the untrasonic sensor HC-SR04.
7.	    The sensor range is between 2cm and 4m.
8.	
9.	    The timeouts received listening to echo pin are converted to OSError('Out of range')
10.	
11.	    """
12.	    # echo_timeout_us is based in chip range limit (400cm)
13.	    def __init__(self, trigger_pin, echo_pin, echo_timeout_us=500*2*30):
14.	        """
15.	        trigger_pin: Output pin to send pulses
16.	        echo_pin: Readonly pin to measure the distance. The pin should be protected with 1k resistor
17.	        echo_timeout_us: Timeout in microseconds to listen to echo pin. 
18.	        By default is based in sensor limit range (4m)
19.	        """
20.	        self.echo_timeout_us = echo_timeout_us
21.	        # Init trigger pin (out)
22.	        self.trigger = Pin(trigger_pin, mode=Pin.OUT, pull=None)
23.	        self.trigger.value(0)
24.	
25.	        # Init echo pin (in)
26.	        self.echo = Pin(echo_pin, mode=Pin.IN, pull=None)
27.	
28.	    def _send_pulse_and_wait(self):
29.	        """
30.	        Send the pulse to trigger and listen on echo pin.
31.	        We use the method `machine.time_pulse_us()` to get the microseconds until the echo is received.
32.	        """
33.	        self.trigger.value(0) # Stabilize the sensor
34.	        sleep_us(5)
35.	        self.trigger.value(1)
36.	        # Send a 10us pulse.
37.	        sleep_us(10)
38.	        self.trigger.value(0)
39.	        try:
40.	            pulse_time = time_pulse_us(self.echo, 1, self.echo_timeout_us)
41.	            # time_pulse_us returns -2 if there was timeout waiting for condition; and -1 if there was timeout during the main measurement. It DOES NOT raise an exception
42.	            # ...as of MicroPython 1.17: http://docs.micropython.org/en/v1.17/library/machine.html#machine.time_pulse_us
43.	            if pulse_time < 0:
44.	                MAX_RANGE_IN_CM = const(500) # it's really ~400 but I've read people say they see it working up to ~460
45.	                pulse_time = int(MAX_RANGE_IN_CM * 29.1) # 1cm each 29.1us
46.	            return pulse_time
47.	        except OSError as ex:
48.	            if ex.args[0] == 110: # 110 = ETIMEDOUT
49.	                raise OSError('Out of range')
50.	            raise ex
51.	
52.	    def distance_mm(self):
53.	        """
54.	        Get the distance in milimeters without floating point operations.
55.	        """
56.	        pulse_time = self._send_pulse_and_wait()
57.	
58.	        # To calculate the distance we get the pulse_time and divide it by 2 
59.	        # (the pulse walk the distance twice) and by 29.1 becasue
60.	        # the sound speed on air (343.2 m/s), that It's equivalent to
61.	        # 0.34320 mm/us that is 1mm each 2.91us
62.	        # pulse_time // 2 // 2.91 -> pulse_time // 5.82 -> pulse_time * 100 // 582 
63.	        mm = pulse_time * 100 // 582
64.	        return mm
65.	
66.	    def distance_cm(self):
67.	        """
68.	        Get the distance in centimeters with floating point operations.
69.	        It returns a float
70.	        """
71.	        pulse_time = self._send_pulse_and_wait()
72.	
73.	        # To calculate the distance we get the pulse_time and divide it by 2 
74.	        # (the pulse walk the distance twice) and by 29.1 becasue
75.	        # the sound speed on air (343.2 m/s), that It's equivalent to
76.	        # 0.034320 cm/us that is 1cm each 29.1us
77.	        cms = (pulse_time / 2) / 29.1
78.	        return cms
 
ДОДАТОК Г
Програмний код клієнтської частини
Г.1 Код сторінки профілю Profile.js


1.	import React, { useState, useEffect, useCallback } from 'react';
2.	import { Layout } from '../components/Layout';
3.	import App from '../App';
4.	import jwtDecode from 'jwt-decode';
5.	import { useTranslation } from 'react-i18next';
6.	
7.	const Profile = () => {
8.	    const userId = localStorage.getItem('userId');
9.	    const { t } = useTranslation();
10.	
11.	    const [userData, setUserData] = useState({});
12.	    const [formData, setFormData] = useState({
13.	        name: '',
14.	        surname: '',
15.	        role: '',
16.	        email: '',
17.	        address: '',
18.	        phone: '',
19.	        recycled: '',
20.	        bonuses: '',
21.	        operations: '',
22.	    });
23.	
24.	    useEffect(() => {
25.	        fetch(`https://localhost:7051/api/User/GetUser/${Number(userId)}`)
26.	            .then(response => response.json())
27.	            .then(data => {
28.	                let initialFormData = {
29.	                    name: data.name,
30.	                    surname: data.surname,
31.	                    role: data.role,
32.	                    email: data.email,
33.	                    address: data.address,
34.	                    phone: data.phone,
35.	                };
36.	
37.	                if(localStorage.getItem('role') !== 'Admin') {
38.	                    initialFormData.recycled = data.userStatistics.recycled;
39.	                    initialFormData.bonuses = data.userStatistics.bonuses;
40.	                    initialFormData.operations = data.operations;
41.	                }
42.	
43.	                setUserData(data);
44.	                setFormData(initialFormData);
45.	            })
46.	            .catch(error => console.error('Error fetching data:', error));
47.	    }, [userId]);
48.	
49.	    const handleInputChange = (e) => {
50.	        const { name, value } = e.target;
51.	        setFormData(prevFormData => ({
52.	            ...prevFormData,
53.	            [name]: value,
54.	        }));
55.	    };
56.	
57.	    const handleFormSubmit = (e) => {
58.	        e.preventDefault();
59.	    };
60.	
61.	    const updateProfile = useCallback(() => {
62.	        const selectedFormData = {
63.	            name: formData.name,
64.	            surname: formData.surname,
65.	            address: formData.address,
66.	            phone: formData.phone
67.	        };
68.	
69.	        fetch(`https://localhost:7051/api/User/UpdateUsertPartially/${userId}`, {
70.	            method: 'PATCH',
71.	            headers: {
72.	                'Content-Type': 'application/json',
73.	            },
74.	            body: JSON.stringify(selectedFormData),
75.	        })
76.	        .then(response => response.json())
77.	        .then(updatedData => {
78.	            setUserData(updatedData);
79.	        })
80.	        .catch(error => console.error('Error updating data:', error));
81.	    }, [formData, userId]);
82.	
83.	    const deleteProfile = useCallback(async () => {
84.	        try {
85.	            const response = await fetch(`https://localhost:7051/api/Users/DeleteUser/${userId}`, {
86.	                method: 'DELETE',
87.	                headers: {
88.	                    'Content-Type': 'application/json',
89.	                },
90.	            });
91.	
92.	            if (!response.ok) {
93.	                throw new Error(`Failed to delete resource with ID ${userId}`);
94.	            }
95.	
96.	        } catch (error) {
97.	            console.error('Error deleting resource:', error);
98.	        }
99.	    }, [userId]);
100.	
101.	    const inputStyle = {
102.	        position: 'absolute', left: '320px',
103.	        outline: 0,
104.	        backgroundColor: '#F1F1F1',
105.	    };
106.	
107.	    let role = localStorage.getItem('role');
108.	
109.	    return (
110.	        <div>
111.	            <h3>{t('yourProfile')}</h3>
112.	            <form onSubmit={handleFormSubmit}>
113.	                <div className='mt-1'>
114.	                    <label>
115.	                        {t('name')}
116.	                        <input
117.	                            className='border-top-0 border-left-0 border-right-0'
118.	                            style={inputStyle}
119.	                            type="text"
120.	                            name="name"
121.	                            value={formData.name}
122.	                            onChange={handleInputChange}
123.	                        />
124.	                    </label>
125.	                </div>
126.	                <div className='mt-1'>
127.	                    <label>
128.	                        {t('surname')}
129.	                        <input
130.	                            className='border-top-0 border-left-0 border-right-0'
131.	                            style={inputStyle}
132.	                            type="text"
133.	                            name="surname"
134.	                            value={formData.surname}
135.	                            onChange={handleInputChange}
136.	                        />
137.	                    </label>
138.	                </div>
139.	                <div className='mt-1'>
140.	                    <label>
141.	                        {t('role')}
142.	                        <input
143.	                            className='border-top-0 border-left-0 border-right-0'
144.	                            style={inputStyle}
145.	                            type="text"
146.	                            name="role"
147.	                            value={formData.role}
148.	                        />
149.	                    </label>
150.	                </div>
151.	                <div className='mt-1'>
152.	                    <label>
153.	                        {t('email')}
154.	                        <input
155.	                            className='border-top-0 border-left-0 border-right-0'
156.	                            style={inputStyle}
157.	                            type="text"
158.	                            name="email"
159.	                            value={formData.email}
160.	                            onChange={handleInputChange}
161.	                        />
162.	                    </label>
163.	                </div>
164.	                {role !== "Admin" ? (
165.	                    <div>
166.	                        <div className='mt-1'>
167.	                            <label>
168.	                                {t('address')}
169.	                                <input
170.	                                    className='border-top-0 border-left-0 border-right-0'
171.	                                    style={inputStyle}
172.	                                    type="text"
173.	                                    name="address"
174.	                                    value={formData.address}
175.	                                    onChange={handleInputChange}
176.	                                />
177.	                            </label>
178.	                        </div>
179.	                        <div className='mt-1'>
180.	                            <label>
181.	                                {t('phone')}
182.	                                <input
183.	                                    className='border-top-0 border-left-0 border-right-0'
184.	                                    style={inputStyle}
185.	                                    type="text"
186.	                                    name="phone"
187.	                                    value={formData.phone}
188.	                                    onChange={handleInputChange}
189.	                                />
190.	                            </label>
191.	                        </div>
192.	                        <div className='mt-1'>
193.	                            <label>
194.	                                {t('birthday')}
195.	                                <input
196.	                                    className='border-top-0 border-left-0 border-right-0'
197.	                                    style={inputStyle}
198.	                                    type="text"
199.	                                    name="birthday"
200.	                                    value={formData.birthday}
201.	                                    onChange={handleInputChange}
202.	                                />
203.	                            </label>
204.	                        </div>
205.	                    </div>
206.	                ) : null}
207.	                
208.	                <div>
209.	                    <button type="submit" className='btn btn-primary mr-3 mt-3' onClick={updateProfile}>{t('updateProfile')}</button>
210.	                    <button type='button' className='btn btn-outline-danger mt-3' onClick={deleteProfile}>{t('deleteAccount')}</button>
211.	                </div>
212.	            </form>
213.	            {role !== "Admin" && (
214.	                <div style={{position: 'absolute', top: '72px', left: '700px'}}>
215.	                    <h3>{t('statistics')}</h3>
216.	                    <p>{t('recycled')}: {formData.recycled}</p>
217.	                    <p>{t('bonuses')}: {formData.bonuses}</p>
218.	                </div>
219.	            )}
220.	
221.	            {role !== "Admin" && (
222.	                <div style={{position: 'absolute', top: '190px', left: '700px', maxWidth: '500px' }}>
223.	                    <h3>{t('operations')}</h3>
224.	                    <table className="table table-striped" style={{ fontSize: '14px' }}>
225.	                        <thead>
226.	                            <tr>
227.	                                <th>{t('id')}</th>
228.	                                <th>{t('trashType')}</th>
229.	                                <th>{t('weight')}</th>
230.	                                <th>{t('volume')}</th>
231.	                                <th>{t('time')}</th>
232.	                                <th>{t('point')}</th>
233.	                            </tr>
234.	                        </thead>
235.	                        <tbody>
236.	                            {Object.values(formData.operations).map((operation, index) => (
237.	                                <tr key={index}>
238.	                                    <td>{operation.id}</td>
239.	                                    <td>{operation.trashType}</td>
240.	                                    <td>{operation.weight}</td>
241.	                                    <td>{operation.volume}</td>
242.	                                    <td>{operation.time}</td>
243.	                                    <td>{operation.collectionPointID}</td>
244.	                                </tr>
245.	                            ))}
246.	                        </tbody>
247.	                    </table>
248.	                </div>
249.	            )}
250.	        </div>
251.	    );
252.	};
253.	
254.	export default Profile;


Г.2 Код сторінки авторизації LogIn.js


1.	import React, { Component } from 'react';
2.	import { Layout } from '../components/Layout';
3.	import App from '../App';
4.	import { Navigate, useNavigate } from 'react-router-dom';
5.	import { jwtDecode } from 'jwt-decode';
6.	
7.	export default class LogIn extends Component {
8.	  constructor(props) {
9.	    super(props);
10.	    this.state = {
11.	      email: '',
12.	      password: '',
13.	      rememberMe: false,
14.	      buttonPressed: false,
15.	      shouldRedirect: false
16.	    };
17.	  }
18.	
19.	  handleInputChange = (event) => {
20.	    const { name, value, type, checked } = event.target;
21.	    const inputValue = type === 'checkbox' ? checked : value;
22.	
23.	    this.setState({ [name]: inputValue });
24.	  };
25.	
26.	  handleButtonPress = async (event) => {
27.	    event.preventDefault();
28.	    this.setState({ buttonPressed: true });
29.	
30.	    const { email, password, rememberMe } = this.state;
31.	
32.	    const url = `https://localhost:7051/token?email=${email}&password=${password}`;
33.	
34.	    try {
35.	      // Make an authorization request to the server
36.	      const response = await fetch(url, {
37.	        method: 'POST', // or 'POST' depending on your server's requirements
38.	        headers: {
39.	          'Content-Type': 'application/json',
40.	        },
41.	         body: JSON.stringify({ email, password, rememberMe }), // Uncomment if you need a POST request
42.	      });
43.	
44.	      if (response.ok) {
45.	        // Update the authorized variable and store it in localStorage
46.	        console.log('success');
47.	        LogIn.authorized = true;
48.	        App.authorized = true;
49.	        const data = await response.json();
50.	        const accessToken = data.access_token;
51.	        localStorage.setItem('token', accessToken)
52.	        localStorage.setItem('authorized', true);
53.	        const decodedToken = jwtDecode(accessToken);
54.	        localStorage.setItem('role', decodedToken['http://schemas.microsoft.com/ws/2008/06/identity/claims/role']);
55.	        localStorage.setItem('userId', decodedToken.sub);
56.	        //window.location.reload();
57.	        //this.setState({ shouldRedirect: true });
58.	        // Use useHistory to navigate to "/data"
59.	              // Refresh the page
60.	        //window.location.reload();
61.	
62.	        // Use setTimeout to delay the redirection after 2 seconds
63.	          // Use useHistory to navigate to "/data"
64.	          //const navigate = useNavigate()
65.	          //this.props.navigation.navigate('/data')
66.	          this.setState({ shouldRedirect: true });
67.	          if (localStorage.getItem('role') == 'Admin') {
68.	            window.location.href = "/data";
69.	          }
70.	          else {
71.	            window.location.href = "/";
72.	          }
73.	        //Layout.refreshComp();
74.	      } else {
75.	        // Handle authentication error
76.	        console.error('Authentication failed');
77.	      }
78.	    } catch (error) {
79.	      console.error('Error during authentication:', error);
80.	    }
81.	  };
82.	
83.	  render() {
84.	    const { shouldRedirect } = this.state;
85.	
86.	    if (shouldRedirect) {
87.	      //return <Navigate to="/data" refresh={"true"}/>;
88.	    }
89.	
90.	    return (
91.	      <form>
92.	        <h3>Log In</h3>
93.	        <div className="mb-3">
94.	          <label>Email address</label>
95.	          <input
96.	            type="email"
97.	            className="form-control"
98.	            placeholder="Enter email"
99.	            name="email"
100.	            value={this.state.email}  // Add this line
101.	            onChange={this.handleInputChange}  // Add this line
102.	          />
103.	        </div>
104.	        <div className="mb-3">
105.	          <label>Password</label>
106.	          <input
107.	            type="password"
108.	            className="form-control"
109.	            placeholder="Enter password"
110.	            name="password"
111.	            value={this.state.password}  // Add this line
112.	            onChange={this.handleInputChange}  // Add this line
113.	          />
114.	        </div>
115.	        <div className="mb-3">
116.	          <div className="custom-control custom-checkbox">
117.	            <input
118.	              type="checkbox"
119.	              className="custom-control-input"
120.	              id="customCheck1"
121.	            />
122.	            <label className="custom-control-label" htmlFor="customCheck1">
123.	              Remember me
124.	            </label>
125.	          </div>
126.	        </div>
127.	        <div className="d-grid">
128.	          <button
129.	            type="submit"
130.	            className="btn btn-primary"
131.	            onClick={this.handleButtonPress}
132.	          >
133.	            Log In
134.	          </button>
135.	        </div>
136.	      </form>
137.	    );
138.	  }
139.	}


Г.3 Код компонента NavMenu.js, що відповідає за навігаційну панель сайту


1.	import React, { Component } from 'react';
2.	import { Button, Collapse, Navbar, NavbarBrand, NavbarToggler, NavItem, NavLink } from 'reactstrap';
3.	import { Link } from 'react-router-dom';
4.	import './NavMenu.css';
5.	import Dropdown from 'react-bootstrap/Dropdown';
6.	import { withTranslation } from 'react-i18next';
7.	
8.	class NavMenu extends Component {
9.	  static displayName = NavMenu.name;
10.	
11.	  constructor(props) {
12.	    super(props);
13.	
14.	    this.toggleNavbar = this.toggleNavbar.bind(this);
15.	    this.state = {
16.	      collapsed: true,
17.	      isVisible: false
18.	    };
19.	  }
20.	
21.	  toggleNavbar() {
22.	    this.setState({
23.	      collapsed: !this.state.collapsed
24.	    });
25.	  }
26.	
27.	  toggleVisibility = () => {
28.	    this.setState(prevState => ({
29.	      isVisible: !prevState.isVisible
30.	    }));
31.	  };
32.	
33.	  refresh() {
34.	    localStorage.setItem('authorized', false);
35.	    console.log(localStorage.getItem('token'));
36.	    localStorage.removeItem('token');
37.	    localStorage.removeItem('role');
38.	    window.location.href = "/";
39.	  }
40.	
41.	  render() {
42.	    const { t } = this.props.i18n;
43.	
44.	    return (
45.	      <header>
46.	        <Navbar className="navbar-expand-sm navbar-toggleable-sm ng-white border-bottom box-shadow mb-3" container light>
47.	          <img src="https://i.pinimg.com/originals/61/88/8d/61888d3723077d6eb5e4f76682689501.png" style={{ width: '23px' }} />
48.	          <NavbarBrand tag={Link} to="/" className='ml-2'>{t('Smart Recycling')}</NavbarBrand>
49.	          <NavbarToggler onClick={this.toggleNavbar} className="mr-2" />
50.	          <Collapse className="d-sm-inline-flex flex-sm-row-reverse mr-5" isOpen={!this.state.collapsed} navbar>
51.	            <ul className="navbar-nav flex-grow">
52.	              <NavItem>
53.	                <NavLink tag={Link} className="text-dark" to="/">{t('home')}</NavLink>
54.	              </NavItem>
55.	              <NavItem>
56.	                <NavLink tag={Link} className="text-dark" to="/collectionPoints">{t('ourPoints')}</NavLink>
57.	              </NavItem>
58.	              {localStorage.getItem('authorized') === 'true' && localStorage.getItem('role') === "Admin" && (
59.	                <NavItem>
60.	                  <NavLink tag={Link} className="text-dark" to="/data">{t('data')}</NavLink>
61.	                </NavItem>
62.	              )}
63.	            </ul>
64.	          </Collapse>
65.	          {localStorage.getItem('authorized') !== 'true' && (
66.	            <Link to="/log-in-form">
67.	              <button type="button" className="btn btn-outline-secondary mr-2">{t('Log in')}</button>
68.	            </Link>
69.	          )}
70.	          {localStorage.getItem('authorized') !== 'true' && (
71.	            <Link to="/sign-up-form">
72.	              <button type="button" className="btn btn-secondary mr-2">{t('Sign up')}</button>
73.	            </Link>
74.	          )}
75.	          {localStorage.getItem('authorized') === 'true' && (
76.	            <div>
77.	              <Dropdown>
78.	                <Dropdown.Toggle variant="primary">
79.	                  {t('me')}
80.	                </Dropdown.Toggle>
81.	                <Dropdown.Menu>
82.	                  <Dropdown.Item as={Link} to="/profile">{t('profile')}</Dropdown.Item>
83.	                  <Dropdown.Item>{t('anotherAction')}</Dropdown.Item>
84.	                  <Dropdown.Item onClick={this.refresh}>{t('logOut')}</Dropdown.Item>
85.	                </Dropdown.Menu>
86.	              </Dropdown>
87.	            </div>
88.	          )}
89.	        </Navbar>
90.	      </header>
91.	    );
92.	  }
93.	}
94.	
95.	export default withTranslation()(NavMenu);

